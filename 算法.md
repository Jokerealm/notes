# 算法笔记

[TOC]



## 一、基础算法

### 1.递归与递推 

**递归**：函数直接或间接==调用自身==

递归要素：

a. 递归终止条件

b. 递归调用

递归可以处理复杂的数据结构和算法，如树和图的遍历，但存在栈溢出的风险

而循环是直接控制流程，适用于规模没有明显缩小或需要特定的迭代次数，适合处理动态规划问题

改进：

当查询操作不止一次的时候，进行记忆化存储

以斐波那契为例

```c++
#include <bits/stdc++.h>

using namespace std;

int F[50];
int f(int n){
	if(F[n]) return F[n];
	if(n <= 2) return 1;
	return	F[n] = f(n-1) + f(n-2);
}
int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cout << f(5);
	return 0;
}
```

### 2.差分

对于一个数组a[],差分diff[]的定义是
$$
diff[i] = a[i] - a[i-1]
$$
差分的**初始化**== O(n)==

```c++
    for(int i = 1; i <= n ;i++){
        diff[i] = a[i] - a[i-1]
    }
```

对差分数组做前缀和可以**还原**得到原数组
$$
a[i] = diff[1] + diff[2] + diff[3] + ... + diff[i]
$$
**性质**

差分数组可以实现快速的区间修改，例如将区间[l,r]都加上x的方法
$$
diff[l] += x;
diff[r+1] -= x;
$$
**原理**:diff[l] += x表示的是从区间的l处开始都加上x,diff[r+1]-=x指的是从区间的r+1处开始都减去x，两者结合即为从[l,r]加上x

[^tip]: 差分数组不能实现"边修改边查询（区间和）"，只能实现“多次修改，一次查询”，如果要实现“边修改边查询”需要使用树状数组、线段树等数据结构。



### 3. 二分

二分是一种利用数据结构的单调性的枚举，时间复杂度为==O(logn)==

**步骤**:

1. 确定单调性
2. 找寻最大区间[l,r]
3. 确定check函数，一般传入mid(区间下标)
4. 计算中点mid=(l+r)/2,check进行l,r边界的移动
5. 返回指定下标

```c++
bool binary_search(int target){
	int l = 0, r = 5;
	while(l <= r){
		int mid = (l+r)/2;
		if( a[mid] == target) return true;
		else if(a[mid] > target) r = mid - 1;
		else l = mid + 1;
	}
	return false;
}
```

==模版==

```c++
	int l = 1, r = n;
	while(l <= r){
        int mid = (l+r)/2;
        if() ans++;
        else if() l = mid + 1;
        else r = mid -1;
    }
```

#### 例题、搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

 

**示例 1：**

```
输入：nums = [4,5,6,7,0,1,2], target = 0
输出：4
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2], target = 3
输出：-1
```

**示例 3：**

```
输入：nums = [1], target = 0
输出：-1
```

 

**提示：**

- `1 <= nums.length <= 5000`
- `-104 <= nums[i] <= 104`
- `nums` 中的每个值都 **独一无二**
- 题目数据保证 `nums` 在预先未知的某个下标上进行了旋转
- `-104 <= target <= 104`

这道题目中我们首先要明确，数组以mid为界限，分为[l, mid - 1],[mid + 1, r],且这两部分一定有一部分是有序的。那么，我们首先需要确定哪一部分是有序的

```c++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if(nums[mid] >= nums[l]){ // mid位于[l, mid - 1]
                // target也位于[l, mid - 1]，且[l, mid - 1]是有序的
                if(target >= nums[l] && target < nums[mid]){ 
                    r = mid - 1;
                }
                else{
                    l = mid + 1;
                }
            }
            else{ // mid位于[mid + 1, r]
                // target也位于[mid + 1, r]，且[mid + 1, r]是有序的
                if(target <= nums[r] && target > nums[mid]){
                    l = mid + 1;
                }
                else{
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



### 4.进制转化

将十进制转换为任意进制

```c++
	int x, k; cin >> x >> k;
	int cnt=0,a[100];
	while(x) a[++cnt] = x%k, x/=k;
	reverse(a+1,a+1+cnt);
	for(int i = 1; i <= cnt; i++) cout << a[i];
```

将任意进制转化为十进制

```c++
	ll x = 0;
	for(int i = 1; i <= n; i++) x = x*k+a[i];
```



### 5.离散化

离散化是一种将数组的值域压缩，从而更加关注元素的大小关系的算法，离散化数组要求内部是有序的（一般是去重的），一般会结合其他算法或数据结构，如树状数组、线段树、二维平面的计算几何等

eg，给定a数组，求a的离散化数组，并可以通过值找到下标

```c++
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
const int N = 1e5+9;

int a[N];
vector<int> L;

int getidx(int x){
	return lower_bound(L.begin(),L.end(),x) - L.begin();
}

int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n; cin >> n;
	for(int i = 1; i<= n; i++) cin >> a[i];
	for(int i = 1; i <= n; i++) L.push_back(a[i]);
	sort(L.begin(), L.end());
	L.erase(unique(L.begin(),L.end()),L.end());
	
	for(const auto &i : L) cout << i << ' ';
	cout << endl;
	int val; cin >> val;
	cout << getidx(val) << endl;
	return 0;
}
```

### 6.前缀和

对于一个数组a[],我们定义一个前缀和数组prefix[],满足：
$$
prefix[i]=\sum_{j=1}^{i}a[j]
$$
prefix数组的初始化
$$
prefix[i]=\sum_{j=1}^{i-1}a[j]+a[i]=prefix[i-1]+a[i]
$$
```c++
	for(int i = 1; i <= n; i++) prefix[i] = prefix[i-1] + a[i];
```



prefix可以O(1)求原数组a[]的一段区间的和：
$$
sum(l,r)=prefix[r]-prefix[l-1]
$$

```c++
	sum = prefix[r] - prefix[l-1];
```

[^notice]: prefix是一种预处理算法，只适用于a[]为静态数组的情况，即a数组中的元素在区间和查询过程中不会进行修改。



### 7.双指针

双指针一般用两个变量来便是下标，而非真的用指针实现。

双指针往往和单调性、排序联系在一起，在数组的问题上，暴力法往往是O(n^2),而双指针利用单调性往往可以优化到==O(n)==

常见的双指针模型有:

1. 对撞指针
2. 快慢指针



#### 对撞指针

**定义**：两个指针left,right分别指向序列的第一个和最后一个元素，l不断递增，r不断递减，直到两个指针的值相撞或其他特殊条件

对撞指针一般用来解决有序数组或字符串的问题（常用于区间问题）：

查找有序数组中满足某些约束条件的一组元素问题：比如二分查找、数字之和等问题。

字符串反转问题：反转字符串、回文数、颠倒二进制等问题

**步骤**

1. 初始化指针位置。left指向第一个元素，right指向最后一个元素
2. 在循环体中将左右指针相向移动
3. 当两指针相撞时，或满足其他要求时，跳出循环体

eg. 给定长度为n的字符串s判断是否回文

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e6+10;
char s[N];

int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	
	cin >> s + 1;
	int n = strlen(s+1);
	int l = 1, r = n;
	bool ans = true;
	while(l <= r){
		if(s[l] != s[r]) ans = false;
		l++, r--;
	}
	cout << (ans ? "y" : "n");
	return 0;
} 
```



#### 快慢指针

快慢指针指的是两个指针从同一侧开始遍历序列，且移动的步长一个快一个慢，我们称快指针为r,慢指针为l,这样快慢指针构成了区间[l,r],两个指针以不同速度、不同策略移动，直到快指针移动到数组尾端，或者两指针相交，或满足其他特殊条件为止。

**步骤:**

1. 初始化两个指针，l指向第一个元素，r指向第0个元素，区间[l,r]=[1,0]为空区间
2. 快慢指针根据条件移动，保持[l,r]为合法区间
3. 指针移动到尾端或两指针相交或其他特殊条件时跳出循环

eg, 给定一个长度为n的序列an和常数s,对于一个连续区间，如果它的区间和大于等于s,则为一个美丽区间，找出美丽区间中最短的区间。

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5+10;
int a[N];

int main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int n,s; cin >> n >> s;
	int ans = n+1, sum = 0;
	for(int i = 1; i <= n; ++i) cin >> a[i];
	// i为慢指针，j为快指针 
	for(int i = 1, j = 0; i <= n; i++){
		while(i > j || (j + 1 <= n && sum <s)) sum += a[++j];
		if(sum >= s) ans = min(ans, j-i+1);
		sum-= a[i];
	}
	cout << (ans > n ? 0 : ans);
	return 0;
} 
```

### 8.位运算

- 判断数字奇偶性: x & 1结果是1说明是奇数，结果为0说明是偶数

- 获取二进制数的某一位: x >> i & 1表示二进制中的第i位

- 修改二进制中的某一位为:  x | (1 << i) 将x的第i位上或1则变成1

- 快速判断一个数是不是2的幂次方: x & (x -1)

[^tip]: 如果x为2的幂次方，则x的二进制表示中只一个1,x-1就有很多个连续的1并且和x的1没有交集，两者的与运算一定是0，其他情况必然都不是2^n^

- 获取二进制中最低位的1: lowbit(x) = x & -x



## 二、排序算法

### 1.插入排序

插入排序基本思想是，将待排序的元素逐个插入到已排序的序列的合适位置中，使得已排序序列逐渐扩大，从而逐步构建有序序列，最终得到完全有序，时间复杂度为==O(n^2^)==

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6+10;
int a[N];

int main(){
	int n; cin >> n;
	for(int i = 1; i <= n;i++)cin >> a[i];
	for(int i = 2; i <= n; i++){
        // 对第i个数进行插入操作
		int val = a[i], j;
        // 找到i的正确位置
		for(j = i; j > 1 && val < a[j-1]; --j){
            // 前面的元素依次后移
			a[j] = a[j-1];
		}
        // 第i个数插入正确位置
		a[j] = val;
	}
	for(int i = 1; i <= n; i++) cout << a[i] << " ";
	return 0;
}
```

### 2.冒泡排序

冒泡排序的基本思想是，把最大的通过不断交换运到最后边，再把第二大的不断交换运到最大项的左侧，以此类推，时间复杂度为==O(n^2^)==

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6+10;
int a[N];

int main(){
	int n; cin >> n;
	for(int i = 1; i <= n;i++)cin >> a[i];
	for(int i = 1; i <= n-1; i++){
		for(int j = i + 1; j <= n; j++){
			if(a[i] > a[j]) swap(a[i], a[j]);
		}
	}
	for(int i = 1; i <= n; i++) cout << a[i] << " ";
	return 0;
}
```

### 3.桶排序

桶排序的基本思想是，将每个值放在其对应的下标中，即将5放到a[5]中，index表示取值，a[index]表示个数

桶排序==O(n)==,牺牲空间换取时间

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6+10;
int a[N];

int main(){
	int n; cin >> n;
	for(int i = 1; i <= n;i++){
		int x;
		cin >> x;
		a[x]++;
	}
	for(int i = 1; i <= n; i++){
		for(int j = 1; j <= a[i]; j++){
			cout << i << " ";
		}
	} 
	return 0;
}
```

### 4.选择排序

和冒泡排序类似，但是选择排序是直接确定元素，而非一个一个交换过去，因此是冒泡排序常数级别的优化，时间复杂度是==O(n^2^)==

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6+10;
int a[N];

int main(){
	int n; cin >> n;
	for(int i = 1; i <= n;i++) cin >> a[i];
	for(int i = 1; i <= n; i++){
		int min_id = 1;
		for(int j = n; j >= i ;j--){
			if(a[j] < a[i]){
				min_id = j;
				swap(a[i],a[min_id]);
			}
		}
	} 
	for(int i = 1; i <= n; i++) cout << a[i] << " ";
	return 0;
}
```

### 5.快速排序

快速排序的基本思路是，利用分治法，将一个数组分成两个子数组，其中一个数组的元素小于另一个子数组的元素，然后使用递归对子数组进行排序。快速排序不断将数组分为两个子数组，递归地对子数组进行排序，最终得到一个有序的数组，时间复杂度为==O(nlogn)==

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6+10;
int a[N];

int partition(int a[], int l, int r){
	int pivot = a[r];
	int i = l, j = r;
	while(i < j){
		while(i < j && a[i] <= pivot) i++;
		while(i < j && a[j] >= pivot) j--;
		if(i < j) swap(a[i], a[j]);
		else swap(a[i], a[r]);
	}
	return i;
}
void quick_sort(int a[], int l, int r){
	if(l < r){
        // 分为两个区间，将左右区间进行排序
		int mid = partition(a, l ,r);
		quick_sort(a,l,mid-1);
		quick_sort(a,mid+1,r);
	}
}
int main(){
	int n; cin >> n;
	for(int i = 1; i <= n;i++) cin >> a[i];
	quick_sort(a, 1, n);
	for(int i = 1; i <= n; i++) cout << a[i] << " ";
	return 0;
}
```

其中用到两个关键的函数，partition()函数进行分区，将比pivot大的放到右边，比pivot小的放到左边，最后返回pivot的位置，quick_sort是排序的主体，将整个区间进行递归的排序。

### 6.归并排序

归并算法和快速排序类似，也是一种基于分治法的排序方法。

原理是，将一个数组分为两个子数组，将子数组向下递归排序后，当数组只有一个元素的时候，则这个子数组一定是有序的，到那时将有序数组进行==O(n)==的合并，最终合并为原数组，时间复杂度为==O(nlogn)==,与快排不同的是需要额外的空间用于合并数组。

[^tip]: 在实际题目中，若是遇到多组数据且数据内部有效，归并排序比快排要快速，优先考虑归并排序

**数组归并**

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6+10;
int a[N],b[N];

void merge(int a[], int l, int r){
	if(l == r) return;
	
	int mid = (l+r)/2;
	merge(a, l ,mid);
	merge(a, mid+1, r);
	
    // pl为左区间指针，pr为右区间指针，pb为辅助数组b[]中已排好的元素位置
	int pl = l, pr = mid + 1, pb = 1;
    // 对左右区间进行遍历
	while(pl <= mid || pr <= r){
        // 如果左边排完后，右边剩下的直接复制到b数组中
		if(pl > mid) b[pb++] = a[pr++];
        // 如果右边排完后，左边剩下的直接复制到b数组中
		else if(pr > r) b[pb++] = a[pl++];
		else{
            // 进行比较，将较小的放到b数组中
			if(a[pl] < a[pr]) b[pb++] = a[pl++];
			else b[pb++] = a[pr++];
		}
	}
    // 将辅助数组复制回原数组
	for(int i = l; i <= r; i++) a[i] = b[i];
}

int main(){
	int n; cin >> n;
	for(int i = 1; i <= n;i++) cin >> a[i];
	merge(a, 1, n);
	for(int i = 1; i <= n; i++) cout << a[i] << " ";
	return 0;
}
```

**链表归并**

```c++
	void partion(vector<ListNode*> lists, int l ,int r){
        if(l == r) return;
        int mid = (l + r) / 2;
        partion(lists, l, mid);
        partion(lists, mid + 1, r);
        merge(lists[l], lists[mid + 1]);
    }
    ListNode* merge(ListNode* l, ListNode* r){
        ListNode* root = new ListNode(-1);
        ListNode* cur = root;
        while(l != NULL && r != NULL){
            if(l->val <= r->val){
                cur->next = l;
                l = l->next;
            }
            else{
                cur->next = r;
                r = r->next;
            }
            cur = cur->next;
        }
        if(!l) cur->next = r;
        if(!r) cur->next = l;
        return root->next;
    }
```



## 三、搜索算法

### 1.DFS回溯

DFS是一种遍历或搜索图、树、或图像等数据结构的算法，常见的是通过某种关系构造出搜索树，搜索树一般为**排列型搜索树**和**子集型搜索树**

- 排列型搜索树：总节点个数一般为**n!**级别，含义是每次枚举选哪个
- 子集型搜索树：总节点个数一般为2^n^级别，含义是对于每个元素选或不选（结果与顺序无关）

DFS是从起始节点开始，沿着一条路径尽可能深入地搜索，直到无法继续为止，然后回溯到前一个节点，继续深入搜索，直到遍历整个范围。DFS使用**栈或递归**管理节点的遍历顺序，一般使用**递归**

#### 例一、求1~n的全排列

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 1e6+10;
int a[N], n;
bool vis[N];
void dfs(int dep){
	if (dep == n+1){
		for(int i = 1; i <= n; i++)cout << a[i] << ' ';
		cout << endl;
		return;
	}
	
	for(int i = 1; i <= n; i++){
		// 排除非法状态 
		if(vis[i]) continue;
		// 修改状态 
		vis[i] = true;
		a[dep] = i;
		// 搜索 
		dfs(dep + 1);
		// 恢复
		vis[i] = false; 
		a[dep] = 0;
	}	
	
}
int main(){
	cin >> n;
	dfs(1);
	return 0;
}
```

回溯的重点在于在dfs搜索后，恢复状态

#### 例二、 n皇后

 <img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20240506105532609.png" alt="image-20240506105532609" style="zoom: 50%;" />

```c++
#include <bits/stdc++.h>

using namespace std;

const int N = 15;
int a[N][N];
int ans = 0, n;

bool check(int x, int y){
	for(int i = 1; i <= x; i++){
        // 所在列检查
		if(a[i][y]) return false;
        // 斜对角线检查
		if(y - i >= 1 && a[x - i][y - i]) return false; 
        if(y + i <= n && a[x - i][y + i]) return false;
	}
	return true;
}

void dfs(int depth){
	if(depth == n + 1){
		ans++;
		return;
	}
	for(int j = 1; j <= n; j++){
		if(check(depth,j)){
			a[depth][j] = 1;
			dfs(depth+1);
			a[depth][j] = 0;
		}
	}
}

int main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	cin >> n;
	dfs(1);
	cout << ans;
}
```

如果我们想要给出所有的方案数的话，使用`Q`作为皇后,`.`作为空棋盘，则有

```c++
#include <vector>
#include <string>

using namespace std;

class Solution {
public:
    vector<vector<string>> res;

    vector<vector<string>> solveNQueens(int n) {
        vector<vector<char>> table(n, vector<char>(n, '.'));
        dfs(n, 0, table);
        return res;
    }

    void dfs(int n, int num, vector<vector<char>>& table) {
        if (num == n) {
            vector<string> solution;
            for (int i = 0; i < n; i++) {
                solution.push_back(string(table[i].begin(), table[i].end()));
            }
            res.push_back(solution);
            return;
        }
        for (int i = 0; i < n; i++) {
            if (check(table, i, num)) {
                table[i][num] = 'Q';
                dfs(n, num + 1, table);
                table[i][num] = '.';
            }
        }
    }

    bool check(vector<vector<char>>& table, int x, int y) {
        for (int i = 0; i < y; i++) {
            if (table[x][i] == 'Q') {
                return false;
            }
        }
        for (int i = x - 1, j = y - 1; i >= 0 && j >= 0; i--, j--) {
            if (table[i][j] == 'Q') {
                return false;
            }
        }
        for (int i = x + 1, j = y - 1; i < table.size() && j >= 0; i++, j--) {
            if (table[i][j] == 'Q') {
                return false;
            }
        }

        return true;
    }
};
```



### 2.记忆化

通常用数组或map进行记忆化，下标一般和dfs的参数对应

记忆化需要保证==重复计算的结果是相同的==，否则会数据失真

#### 例一、 斐波那契数列

```c++
#include <bits/stdc++.h>

using namespace std;
const int N = 1e5+10;
using ll = long long;
ll a[N];

ll f(int n){
	if(a[n]) return a[n];
	  
	if(n <= 2){
		a[n] = 1;
		return a[n];
	}
	else{
		a[n] = f(n-1) + f(n-2);
		return a[n];
	}
}

int main(){
	cout << f(50);
	return 0;
}
```

### 3.哈希

#### 例一、两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

可以按任意顺序返回答案。

```c++
vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hs;
        for(int i = 0; i < nums.size(); ++i){
            auto t = hs.find(target - nums[i]);
            if(t != hs.end()){
                return {t->second, i};
            }
            hs[nums[i]] = i;
        }
        return {};
    }
```

#### 例二、字母异位词

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

**示例 1:**

```
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]
```

**示例 2:**

```
输入: strs = [""]
输出: [[""]]
```

**示例 3:**

```
输入: strs = ["a"]
输出: [["a"]]
```

**提示：**

- `1 <= strs.length <= 104`
- `0 <= strs[i].length <= 100`
- `strs[i]` 仅包含小写字母

```c++
class Solution {
public:
    vector<vector<string>> groupAnagrams(vector<string>& strs) {
        unordered_map<string, vector<string>> hs;
        for(auto str : strs){
            string key = str;
            sort(key.begin(), key.end());
            hs[key].push_back(str);
        }
        vector<vector<string>> ans;
        for(auto key : hs){
            ans.push_back(key.second);
        }
        return ans;
    }
};
```

#### 例三、数字连续的最长序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1：**

```
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
```

**示例 2：**

```
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
```

**提示：**

- `0 <= nums.length <= 105`
- `-109 <= nums[i] <= 109`

```c++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> set;
        int ans = 0;
        for(int num : nums){
            set.insert(num);
        }
        for(int num : set){
            if(!set.count(num-1)){
                int cnt = 1;
                int cur_num = num;
                while(set.count(cur_num + 1)){
                    cnt ++;
                    cur_num++;
                }
                ans = max(ans, cnt);
            }
        }
        return ans;
    }
};
```

### 4.滑动窗口

滑动窗口主要是使用两个指针创建一个窗口维持数据，并通过窗口上一步的数据只进行少量的计算维护下一步的数据，减少操作量。

==维持数据是关键，例如左右指针移动并非单调加减时不能使用双指针。==

#### 例一、无重复字符的最长子串

给定一个字符串 `s` ，请你找出其中不含有重复字符的**最长子串**的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

```c++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        // map记录每个字符最后出现的位置
        unordered_map<char, int> hs;
        int maxLen = 0;
        int index = 0;
        // 在无重子串中，寻找是否新字符重复，不重复就加入，反之窗口左边界跳转到最后一次出现的位置
        for(int i = 0; i < s.size(); i++){
            const char c = s[i];
            // 更新窗口位置(max是用来保证窗口index位置只能向右更新)
            if(hs.find(c) != hs.end()){
                index = max(hs[c]+1, index);
            }
            hs[c] = i;
            int curLen = i - index + 1;
            if(curLen > maxLen) maxLen = curLen;
        }
        return maxLen;
    }
};
```

#### 例二、找到字符串中所有字母异位词

eg.,给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

**示例 1:**

```
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。
```

 **示例 2:**

```
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
```

**提示:**

- `1 <= s.length, p.length <= 3 * 104`
- `s` 和 `p` 仅包含小写字母



假设这道题目不使用滑动窗口，直接判断子串，会超时

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        int l = 0;
        vector<int> res;
        for(int i = 0; i < s.size(); i++){
            string str_s = s.substr(i,p.size());
            sort(str_s.begin(),str_s.end());
            string str_p = p;
            sort(str_p.begin(), str_p.end());
            if(str_s == str_p) res.push_back(i);
        }
        return res;
    }
};
```

使用滑动窗口

```c++
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        if (s.size() < p.size()) return res;

        vector<int> c1 = count(s, 0, p.size());
        vector<int> c2 = count(p, 0, p.size());

        for (int i = 0; i <= s.size() - p.size(); i++) {
            if (c1 == c2) res.push_back(i);
            if (i < s.size() - p.size()) {
                c1[s[i] - 'a']--;
                c1[s[i + p.size()] - 'a']++;
            }
        }

        return res;
    }

    vector<int> count(const string& s, int start, int end) {
        vector<int> cnt(26, 0);
        for (int i = start; i < end; i++) {
            cnt[s[i] - 'a']++;
        }
        return cnt;
    }
};
```

### 5.子串

#### 例一、和为k的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`

```c++
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        vector<int> sum(nums.size(), 0);
        sum[0] = nums[0];
        int cnt = 0;
        for(int i = 1; i < nums.size(); i++){
            sum[i] = sum[i-1] + nums[i];
        }
        unordered_map<int, int> hs;
        hs[0] = 1;
        for(int i = 0; i < nums.size() - 1; i++){
            if(hs.find(sum[i] - k) != hs.end()){
                cnt += hs[sum[i]-k];
            }
            hs[sum[i]]++;
        }
        return cnt;
    }
};
```

#### 例二、滑动窗口最大

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

**示例 1：**

```
输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
输出：[3,3,5,5,6,7]
解释：
滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
```

**示例 2：**

```
输入：nums = [1], k = 1
输出：[1]
```

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `1 <= k <= nums.length`



## 四、二叉树

### 1.遍历

#### 中序遍历

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg)

```
输入：root = [1,null,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

 

**提示：**

- 树中节点数目在范围 `[0, 100]` 内
- `-100 <= Node.val <= 100`

**迭代**

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        deque<TreeNode*> stack;
        vector<int> res;
        while(root != NULL || !stack.empty()){
            while(root != NULL){
                stack.push_front(root);
                root = root->left;
            }
            root = stack.front();
            stack.pop_front();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```

**递归**

```c++
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        deque<TreeNode*> stack;
        vector<int> res;
        traversal(root, res);
        return res;
    }
    void traversal(TreeNode* root, vector<int>& res){
        if(!root){
            return;
        }
        traversal(root->left, res);
        res.push_back(root->val);
        traversal(root->right, res);
    }
};
```

#### 2.求二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。

二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/26/tmp-tree.jpg)

 

```
输入：root = [3,9,20,null,null,15,7]
输出：3
```

**示例 2：**

```
输入：root = [1,null,2]
输出：2
```

 

**提示：**

- 树中节点的数量在 `[0, 104]` 区间内。
- `-100 <= Node.val <= 100`

```c++
 int maxDepth(TreeNode* root) {
    return root == NULL ? 0 : max(maxDepth(root->left),maxDepth(root->right)) + 1;
}
```



#### 3.反转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert1-tree.jpg)

```
输入：root = [4,2,7,1,3,6,9]
输出：[4,7,2,9,6,3,1]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/03/14/invert2-tree.jpg)

```
输入：root = [2,1,3]
输出：[2,3,1]
```

**示例 3：**

```
输入：root = []
输出：[]
```

 

**提示：**

- 树中节点数目范围在 `[0, 100]` 内
- `-100 <= Node.val <= 100`

```c++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return NULL;
        TreeNode* l = invertTree(root->right);
        TreeNode* r = invertTree(root->left);
        root->left = l;
        root->right = r;
        return root;
    }
};
```

### 4.二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

 

**提示：**

- 树中节点数目在范围 `[1, 104]` 内
- `-100 <= Node.val <= 100`

```c++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) {
        if(!root) return 0;
        return process(root)[1];
    }
    int* process(TreeNode* root){
        if(!root) return NULL;
        int* l = process(root->left);
        int* r = process(root->right);

        int h = 0;
        int d = 0;
        if(l != NULL){
            h = l[0] + 1;
            d = l[0] + 1;
        }
        if(r != NULL){
            h = max(h, r[0] + 1);
            d = d + r[0] + 1;
        }
        if(l != NULL){
            d = max(d, l[1]);
        }
        if(r != NULL){
            d = max(d, r[1]);
        }
        return new int[]{h,d};
    }
};
```

### 5.层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/tree1.jpg)

```
输入：root = [3,9,20,null,null,15,7]
输出：[[3],[9,20],[15,7]]
```

**示例 2：**

```
输入：root = [1]
输出：[[1]]
```

**示例 3：**

```
输入：root = []
输出：[]
```

**提示：**

- 树中节点数目在范围 `[0, 2000]` 内
- `-1000 <= Node.val <= 1000`



```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        deque<TreeNode*> que;
        if(root != nullptr)  que.push_back(root);
        vector<vector<int>> res;
        while(!que.empty()){
            vector<int> store;
            for(int i = que.size(); i > 0; --i){
                TreeNode* tmp = que.front();
                que.pop_front();
                store.push_back(tmp->val);
                if(tmp->left) que.push_back(tmp->left);
                if(tmp->right) que.push_back(tmp->right);
            }
            res.push_back(store);
        }
        return res;
    }
};
```

### 6.将有序数组转换为二叉树

给你一个整数数组 `nums` ，其中元素已经按 **升序** 排列，请你将其转换为一棵平衡二叉搜索树。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree1.jpg)

```
输入：nums = [-10,-3,0,5,9]
输出：[0,-3,9,-10,null,5]
解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/btree.jpg)

```
输入：nums = [1,3]
输出：[3,1]
解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 按 **严格递增** 顺序排列

```c++

class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return buildTree(nums, 0, nums.size()-1);
    }
    TreeNode* buildTree(vector<int>& nums, int l, int r){
        if(l > r) return NULL;
        int mid = (l + r) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        TreeNode* left = buildTree(nums, l, mid-1);
        TreeNode* right = buildTree(nums, mid + 1, r);
        root->left = left;
        root->right = right;
        return root; 
    }
};
```

### 7.二叉树展平为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg)

```
输入：root = [1,2,5,3,4,null,6]
输出：[1,null,2,null,3,null,4,null,5,null,6]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [0]
输出：[0]
```

**提示：**

- 树中结点数在范围 `[0, 2000]` 内
- `-100 <= Node.val <= 100`



思路：这个题可以使用迭代或递归去前序遍历展平，但是空间复杂度为`O(n)`,要想使用原地算法，一个很关键的思想是"前驱节点"，即找到每一个节点正确的前一个节点。对于二叉树来说，==每个节点如果左节点为空，则不需要进行展开操作==；==如果左节点不为空，则左子树中的最后一个节点被访问后，再访问右子树==。因此，找到左子树中的最后一个节点作为右子树的前驱结点即可。

```c++
class Solution {
public:
    void flatten(TreeNode* root) {
        if (!root)    return;
        TreeNode* cur = root;
        while (cur != nullptr) {
            if (cur->left) {
                TreeNode* pre = cur->left;
                while (pre->right != nullptr) {
                    pre = pre->right;
                }
                pre->right = cur->right;
                cur->right = cur->left;
                cur->left = nullptr;
            }
            cur = cur->right;
        }
    }
};
```

### 8.路径总和

给定一个二叉树的根节点 `root` ，和一个整数 `targetSum` ，求该二叉树里节点值之和等于 `targetSum` 的 **路径** 的数目。

**路径** 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg)

```
输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
输出：3
解释：和等于 8 的路径有 3 条，如图所示。
```

**示例 2：**

```
输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
输出：3
```

 

**提示:**

- 二叉树的节点个数的范围是 `[0,1000]`
- `-109 <= Node.val <= 109` 
- `-1000 <= targetSum <= 1000` 



这道题是二叉树的遍历求和，两次递归，一次是递归去遍历所有节点，一个是去求此节点为路径开头的所有符合题意的方案数。

```c++
class Solution {
public:
    int pathSum(TreeNode* root, long targetSum) {
        if(!root) return 0;
        int res = f(root, targetSum);
        res += pathSum(root->left, targetSum);
        res += pathSum(root->right, targetSum);
        return res;
    }
    int f(TreeNode* root, long targetSum){
        if(!root) return 0;
        int res = 0;
        if(root->val == targetSum){
            res++;
        }
        res += f(root->left, targetSum - root->val);
        res += f(root->right, targetSum - root->val);
        return res;
    }
};
```

## 五、图论

### 1.感染法

#### 例一、岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`



```c++
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        int n = grid.size();
        int m = grid[0].size();
        int res = 0;
        for(int x = 0; x < n; x++){
            for(int y = 0; y < m; y++){
                if(grid[x][y] == '1'){
                    dfs(grid, x, y);
                    res ++;
                }
            }
        }
        return res;
    }
    void dfs(vector<vector<char>>& grid, int x, int y){
        int n = grid.size();
        int m = grid[0].size();
        if(x >= n || x < 0) return;
        if(y >= m || y < 0) return;

        if(grid[x][y] == '1'){
            grid[x][y] = 'y';
            dfs(grid, x + 1, y);
            dfs(grid, x, y + 1);
            dfs(grid, x - 1, y);
            dfs(grid, x , y - 1);
        }
    }
};
```



### 2.邻接表

#### 例

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

 

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**



我们可以发现这是一个拓扑排序的问题，对此我们有两种思路，一种是邻接表进行bfs，一种是dfs判断是否有环和是否有孤立点。这里我们使用邻接表进行求解，关键是设立入度、邻接表和队列，不断将入度为0的加入队列，并减小其相邻未访问点的出度，直到队列为空。

```c++
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        queue<int> q;
        vector<int> indegree(numCourses);
        vector<vector<int>> adjacency(numCourses);
        for(auto pair : prerequisites){
            indegree[pair[0]]++;
            adjacency[pair[1]].push_back(pair[0]);
        }
        for(int i = 0; i < numCourses; i++){
            if(!indegree[i]) q.push(i);
        }
        while(!q.empty()){
            int idx = q.front();
            q.pop();
            numCourses--;
            for(auto course : adjacency[idx]){
                if(!--indegree[course]){
                    q.push(course);
                }
            }
        }
        return !numCourses;
    }
};
```

### 3.前缀树

前缀树是一种树形数据结构，用于高效地存储和检索字符串数据集中的键，有多个应用场景，例如自动补全和拼写检查。下面是前缀树的实现过程，其中包括构造器`Trie()`,插入字符串`insert`,搜索`search`,前缀检验`startsWith`.

```c++
class Trie {
private:
    bool isEnd;
    Trie* next[26];
public:
    Trie() {
        isEnd = false;
        memset(next, 0 ,sizeof(next));
    }
    
    void insert(string word) {
        Trie* node = this;
        for(char c : word){
            if(node->next[c-'a'] == NULL){
                node->next[c-'a'] = new Trie();
            }
            node = node->next[c-'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        Trie* node = this;
        for(char c : word){
            node = node->next[c-'a'];
            if(node == NULL){
                return false;
            }
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        Trie* node = this;
        for(char c : prefix){
            node = node->next[c-'a'];
            if(node == NULL){
                return false;
            }
        }
        return true;
    }
};
```

## 六、回溯

回溯的核心是==递归==

**回溯模版：**

```c++
void process(路径，选择列表){
	if(终止条件){
		添加结果();
		return;
	}
	for(解 : 解空间){
		处理节点();
		process(路径，选择列表);
		回溯(); // 撤销处理结果
	}
}
```

### 例一、全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

**示例 2：**

```
输入：nums = [0,1]
输出：[[0,1],[1,0]]
```

**示例 3：**

```
输入：nums = [1]
输出：[[1]]
```

 

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**



对每个位置进行列举

```c++
class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> res;
        process(nums, 0, res);
        return res;
    }
    void process(vector<int>& nums, int index, vector<vector<int>>& res){
        if(index == nums.size()){ // 如果枚举完每个位置，则终止
            vector<int> tmp;
            for(int num : nums){
                tmp.push_back(num);
            }
            res.push_back(tmp);
            return;
        }
        for(int i = index; i < nums.size(); i++){
            swap(nums[index], nums[i]); // 处理第index个位置
            process(nums, index + 1, res);
            swap(nums[index], nums[i]); // 回溯
        }
    }
};
```

### 例二、生成幂集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

 

**示例 1：**

```
输入：nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

**示例 2：**

```
输入：nums = [0]
输出：[[],[0]]
```

 

**提示：**

- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有元素 **互不相同**



```c++
class Solution {
public:
    vector<vector<int>> subsets(vector<int>& nums) {
        vector<vector<int>> res;
        vector<int> tmp;
        process(nums, 0, res, tmp);
        return res;
    }

    void process(vector<int>& nums, int index, vector<vector<int>>& res, vector<int>& tmp){
        if (index == nums.size()) {
            res.push_back(tmp);
            return;
        }
        // 不选择当前元素
        process(nums, index + 1, res, tmp); 
        
        // 选择当前元素
        tmp.push_back(nums[index]);
        process(nums, index + 1, res, tmp);
        tmp.pop_back(); // 回溯
    }
};
```

### 例三、电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

 

**示例 1：**

```
输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
```

**示例 2：**

```
输入：digits = ""
输出：[]
```

**示例 3：**

```
输入：digits = "2"
输出：["a","b","c"]
```

 

**提示：**

- `0 <= digits.length <= 4`
- `digits[i]` 是范围 `['2', '9']` 的一个数字。



```c++
class Solution {
private:
    vector<string> phone = 
    {
        "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"
    };
public:
    vector<string> letterCombinations(string digits) {
        vector<string> res;
        if(digits == "") return res;
        string tmp;
        process(digits, 0, res, tmp);
        return res;
    }
    void process(string digits, int index, vector<string>& res, string& tmp){
        if(index == digits.size()){
            res.push_back(tmp);
            return;
        }
        int idx = digits[index] - '2'; 
        for(char c : phone[idx]){
            tmp.push_back(c);
            process(digits, index + 1, res, tmp);
            tmp.pop_back();
        }
    }
};
```



### 例四、组合总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

 

**示例 1：**

```
输入：candidates = [2,3,6,7], target = 7
输出：[[2,2,3],[7]]
解释：
2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
7 也是一个候选， 7 = 7 。
仅有这两种组合。
```

**示例 2：**

```
输入: candidates = [2,3,5], target = 8
输出: [[2,2,2,2],[2,3,3],[3,5]]
```

**示例 3：**

```
输入: candidates = [2], target = 1
输出: []
```

 

**提示：**

- `1 <= candidates.length <= 30`
- `2 <= candidates[i] <= 40`
- `candidates` 的所有元素 **互不相同**
- `1 <= target <= 40`



```c++
class Solution {
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        vector<vector<int>> res;
        vector<int> choose;
        process(candidates, 0, target, res, choose);
        return res;
    }
    void process(vector<int>& candidates, int idx, int target, vector<vector<int>>& res, vector<int>& choose){
        if(target == 0){
            res.push_back(choose);
            return;
        }
        if(target < 0 || idx >= candidates.size()) return;
        
        // 不选择当前元素
        process(candidates, idx + 1, target, res, choose);
        
        // 选择当前元素
        choose.push_back(candidates[idx]);
        process(candidates, idx, target - candidates[idx], res, choose);
        choose.pop_back();  // 回溯
    }
};
```

### 例五、括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。==（有效意味着生成过程中，左括号数量大于等于右括号数量）==

 

**示例 1：**

```
输入：n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```

**示例 2：**

```
输入：n = 1
输出：["()"]
```



```c++
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> res;
        string choose;
        process(n, n, choose, res);
        return res;
    }
    void process(int n1, int n2, string choose, vector<string>& res){
        if(!n1 && !n2){
            res.push_back(choose);
            return;
        }
        if (n1 > 0) {
            choose.push_back('(');
            process(n1 - 1, n2, choose, res);
            choose.pop_back();
        }
        if (n2 > n1) { 
            choose.push_back(')');
            process(n1, n2 - 1, choose, res);
            choose.pop_back();
        }
    }
};
```

## 七、贪心算法

贪心算法往往用在==最优子结构==问题上，很符合人类的直觉。



## 八、动态规划





### 例一、完全平方数

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

**提示：**

- `1 <= n <= 104`



首先我们找到题目中的条件为$n=\sum\limits_{i=k}^{j}i^2$,我们需要找到$j$个数最少的情况，同时还可以知道$1{\le}k\le\sqrt{n}$,因此我们可以列举k并统计个数去找到个数最少的情况。考虑状态转移的时候，可以知道`n`是由`n-i^2`转移过来的，我们写出状态转移方程$dp[n]=min(dp[n-i^2]+1,dp[n]),i\in[1,\sqrt{n}]$

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n + 1);
        for (int i = 1; i <= n; i++) {
            int num = INT_MAX;
            for (int j = 1; j * j <= i; j++){
                num = min(dp[i - j*j] + 1, num);
            }
            dp[i] = num;
        }
        return dp[n];
    }
};
```

### 例二、硬币问题

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`



这道题和上一道题很相似。我们的状态空间为剩余金额，那么凑齐金额`amount`所需的方案是从`amount-coins[i]`转移过来的,因此状态转移方程为$dp[amount]=min(dp[amount-coins[i]],dp[amount])$

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        if(amount<0) return -1;
        if(amount == 0) return 0;
        vector<int> dp(amount+1, INT_MAX);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++){
            for(int coin : coins){
                if(  i-coin >= 0&&dp[i-coin] != INT_MAX){
                    dp[i] = min(dp[i-coin]+1, dp[i]);
                }
            }
        }
        return dp[amount] == INT_MAX? -1 : dp[amount];
    }
};
```



### 例三、单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 

**示例 1：**

```
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。
```

**示例 2：**

```
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
     注意，你可以重复使用字典中的单词。
```

**示例 3：**

```
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false
```

 

**提示：**

- `1 <= s.length <= 300`
- `1 <= wordDict.length <= 1000`
- `1 <= wordDict[i].length <= 20`
- `s` 和 `wordDict[i]` 仅由小写英文字母组成
- `wordDict` 中的所有字符串 **互不相同**



我们状态空间为`s`,`dp[i]`表示前$i$位是否可以被拆分,因此$dp[i]=true\space when\space dp[i-wordDict[j].size()]$

```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        int n = s.size();
        vector<bool> dp(n+1, false);
        dp[0] = true;
        for(int i = 1; i <= n; i++){
            for(string t : wordDict){
                int size = t.size();
                if(i-size >= 0 && dp[i-size] && s.substr(i-size,size) == t){
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[n];
    }
};
```

### 4.最长上升子序列

默认情况下（一般而言），子序列是==非连续的==，子数组、子串是==连续==的。



```c++

```

## 九、技巧

### 1.异或——对偶数个数的特殊处理

异或有着很特殊的数学性质，一个数对其自身的异或是0，对其他数的异或均非0。且异或具有交换律，因此，我们如果对所有数进行异或，则出现偶数次数的数会抵消，只留下出现奇数个数的数的异或。

#### 例子 找出只出现一次的数

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间 

**示例 1 ：**

```
输入：nums = [2,2,1]
输出：1
```

**示例 2 ：**

```
输入：nums = [4,1,2,1,2]
输出：4
```

**示例 3 ：**

```
输入：nums = [1]
输出：1
```

**提示：**

- `1 <= nums.length <= 3 * 104`
- `-3 * 104 <= nums[i] <= 3 * 104`
- 除了某个元素只出现一次以外，其余每个元素均出现两次。



```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int num : nums){
            res ^= num;
        }
        return res;
    }
};
```

### 2.BM投票算法（摩尔投票）

一个数组中有且仅有一个个数大于50%的数，找到这个数

```c++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int res = nums[0];
        int cnt = 1;
        for(int i = 1; i < nums.size(); i++){
            if(cnt == 0){
                res = nums[i];
            }
            if(res == nums[i]){
                cnt ++;
            }
            else{
                cnt--;
            }
        }
        return res;
    }
};
```

